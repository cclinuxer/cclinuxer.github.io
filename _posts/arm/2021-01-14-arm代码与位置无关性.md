



# ARM代码与位置无关性

​	网络上关于代码与位置无关性的讲解很多，但是很少有文章真正是把这个知识点讲清楚了的。为了在实际的开发项目过程中，在应用层发生段错误的时候，能够像内核kernel panic一样打印出错时候的栈回溯信息，我们应该对代码的实际运行地址以及连接时候的地址进行研究。这样为后续实现在内核中打印应用层栈回溯功能打下一个基础。

​    为了更好的研究ARM代码与位置的无关性，我们以一个简单的程序为例子，一步一步分析汇编代码，以及程序的可各个section，从而精确的分析arm位置无关代码的实现。



为了测试位置无关性，我们编译一个动态库

```c
/*************************************************************************
        > File Name: add.c
        > Author: Albert Huang
        > Mail: huangjieajy@163.com 
        > Created Time: 2021年01月14日 星期四 15时00分39秒
 ************************************************************************/

#include<stdio.h>

int add(int a, int b)
{
        return a + b;
}
```

使用如下命令进行编译：

>  `/opt/toolchain-arm_cortex-a7_gcc-5.2.0_musl-1.1.16_eabi/bin/arm-openwrt-linux-gcc -fPIC -shared add.c -o libadd.so`

这里是使用动态库的代码：

```c
/*************************************************************************
        > File Name: main.c
        > Author: Albert Huang
        > Mail: huangjieajy@163.com 
        > Created Time: 2021年01月14日 星期四 15时01分26秒
 ************************************************************************/

#include<stdio.h>

int main()
{
        int c = add(2,3);
        printf("this is c value = %d",c);
        return 0;
}
```

使用如下指令进行编译：

> `/opt/toolchain-arm_cortex-a7_gcc-5.2.0_musl-1.1.16_eabi/bin/arm-openwrt-linux-gcc main.c  -o main -L./ -ladd`



编译完成后，我们需要反汇编出可执行文件main的汇编代码：

> `/opt/toolchain-arm_cortex-a7_gcc-5.2.0_musl-1.1.16_eabi/bin/arm-openwrt-linux-objdump -d -s main > main.s`



我们只直接看main函数的汇编代码：

```assembly
0001058c <main>:
   1058c:       e92d4800        push    {fp, lr}
   10590:       e28db004        add     fp, sp, #4
   10594:       e24dd008        sub     sp, sp, #8
   10598:       e3a01003        mov     r1, #3
   1059c:       e3a00002        mov     r0, #2
   105a0:       ebffff95        bl      103fc <_init+0x2c> ;这里实际就是执行add函数
   105a4:       e50b0008        str     r0, [fp, #-8]
   105a8:       e51b1008        ldr     r1, [fp, #-8]
   105ac:       e30005d4        movw    r0, #1492       ; 0x5d4
   105b0:       e3400001        movt    r0, #1
   105b4:       ebffff8d        bl      103f0 <_init+0x20>
   105b8:       e3a03000        mov     r3, #0
   105bc:       e1a00003        mov     r0, r3
   105c0:       e24bd004        sub     sp, fp, #4
   105c4:       e8bd8800        pop     {fp, pc}
```

从上面的代码可以看出，调用add函数的时候，不再是直接调用add函数的地址，而是调用.glt表中的内容： 

`bl      103fc <_init+0x2c>`

我们看下程序的_init向下偏移**0x2c**处的内容:

```assembly
Disassembly of section .init:

000103d0 <_init>:
   103d0:       e92d4001        push    {r0, lr}
   103d4:       e8bd4001        pop     {r0, lr}
   103d8:       e12fff1e        bx      lr

Disassembly of section .plt:

000103dc <.plt>:
   103dc:       e52de004        push    {lr}            ; (str lr, [sp, #-4]!)
   103e0:       e59fe004        ldr     lr, [pc, #4]    ; 103ec <_init+0x1c>
   103e4:       e08fe00e        add     lr, pc, lr
   103e8:       e5bef008        ldr     pc, [lr, #8]!
   103ec:       000102d4        .word   0x000102d4
   103f0:       e28fc600        add     ip, pc, #0, 12
   103f4:       e28cca10        add     ip, ip, #16, 20 ; 0x10000
   103f8:       e5bcf2d4        ldr     pc, [ip, #724]! ; 0x2d4
   103fc:       e28fc600        add     ip, pc, #0, 12  
   10400:       e28cca10        add     ip, ip, #16, 20 ; 0x10000
   10404:       e5bcf2cc        ldr     pc, [ip, #716]! ; 0x2cc
   10408:       e28fc600        add     ip, pc, #0, 12
   1040c:       e28cca10        add     ip, ip, #16, 20 ; 0x10000
   10410:       e5bcf2c4        ldr     pc, [ip, #708]! ; 0x2c4
   10414:       e28fc600        add     ip, pc, #0, 12
   10418:       e28cca10        add     ip, ip, #16, 20 ; 0x10000
   1041c:       e5bcf2bc        ldr     pc, [ip, #700]! ; 0x2bc
   10420:       e28fc600        add     ip, pc, #0, 12
   10424:       e28cca10        add     ip, ip, #16, 20 ; 0x10000
   10428:       e5bcf2b4        ldr     pc, [ip, #692]! ; 0x2b4
```



​	实际跳转后执行的是如下几条指令：

```cassandra
   103fc:       e28fc600        add     ip, pc, #0, 12  
   10400:       e28cca10        add     ip, ip, #16, 20 ; 0x10000
   10404:       e5bcf2cc        ldr     pc, [ip, #716]! ; 0x2cc
```



这个博主的书可以看下：

http://nicephil.blinkenshell.org/my_book/index.html



这个讲解也可以：要好好研究下：

https://zhuanlan.zhihu.com/p/94362447



斯坦福大学：

https://www.cs.stevens.edu/~jschauma/631/elf.html



main函数call  .plt段中的一个地址，这里的第一句话就是调转到.got.plt中的保存的printf的地址，如果是第一次，那么保存的地址就是.plt中的下一句话，这个下一句话就是压入这个符号在.rel.plt中的重定位表的偏移量，然后ld程序就会根据重定位表中的信息加上这个偏移量找到这个地址，保存到重定位表所指向的地址中，这个地址其实就是.got.plt段的一个地址。